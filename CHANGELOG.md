### v1.1.14 (18.10.19) 

#### 1. Функцию обработки данных на плагине можно запускать для подканалов (I2C, MCP)

Ранее функция была привязана к номеру порта контроллера, теперь - к идентификатору канала

----

### v1.1.14 (29.03.19) 

#### 1. Расширен объект-параметр сценария, запускаемого при запросе

При запуске сценария при получении запроса от контроллера в объект параметра добавлен ip-адрес

#### 2. Добавлен разбор каналов MCP 

Работа с расширенными каналами выполняется аналогично обычным, за исключением того, что на один порт сажается несколько входов-выходов, поэтому:

1. В сообщении в ответ на /pt=32&cmd=get передает 8 (16) значений через ;

```ON;OFF;OFF;OFF;OFF;OFF;OFF```

При парсинге этого запроса данные передаются в каналы:
32_1,...32_8 - нумерация каналов начинается с 1!!!


2. В ответе на cmd=all этих значений нет, для 32 канала пишется MCP:

```ON;OFF;....;temp:23.00/hum:24.00;MCP;...```


-----

### v1.1.12 (21.01.19) 

#### 1. При запуске сценария при получении запроса от контроллера добавлена возможность передать параметр

 - Можно прописать параметр жестко в настройке. После выбора сценария становится доступно строковое поле **Параметр сценария**

  - Если **Параметр сценария** не заполнен, сценарий получает на входе объект запроса.

-----

### v1.1.11 (19.01.19) 

#### 1. Добавлена настройка канала AO для управления аналоговыми актуаторами (диммер) и RGB.

Само управление выполняется через меню устройства в основном интерфейсе, версия системы 4.4.12

#### Настройка диммера

При выборе AO появляется строка **Команда управления**, по умолчанию пустая.

Если ее оставить пустой, будет использоваться стандартная команда: 
```/%pwd%/?cmd=%adr%:%value%  (после подстановки /sec/?cmd=12:255)```


Для преобразования значения логического уровня (яркость 0-100%) в значение физического уровня (0-255) служат два следующих параметра:

  - Значения логического уровня 0-
  - Значения физического уровня 0-
 
Обратите внимание, что значение логического уровня должно соответствовать max значению виртуального устройства, иначе слайдер будет работать некорректно.

Для использования других команд MegaD пропишите команду строке **Команда управления**, например:
```/%pwd%/?pt=%adr%&pwm=%value%&cnt=2 (/sec/?pt=12&pwm=255&cnt=2)```

Можно прописать пароль/ адрес напрямую в команде
```/sec/?pt=12&pwm=%value%&cnt=2```

#### Настройка RGB
Также используется канал AO, к нему надо привязать виртуальное устройство типа RGB

В системе имеется 3 типа RGB устройств:
  - RGB (3 канала),
  - RGBW (4 канала), 
  - RGBWW - (5 каналов).
  
Для MegaD нужно выбрать 3 канальный вариант.

Название канала лучше дать абстрактное, не привязанное к каналу (rgb35, myrgb, ...)

В строке **Команда управления** прописать, например

```/%pwd%/?pt=35&ws=%value%```

Параметры "Значение физического уровня", "Значение логического уровня" никакого влияния на rgb не оказывают

#### 2. Добавлена возможность запустить сценарий при получении запроса от контроллера

  Сценарий выбирается в таблице запросов.

-----

### v1.1.10 (14.01.19) 

#### 1. Добавлена отправка команды плагину из сценария - любые запросы, которые принимает MegaD 

   Например, выдать импульс:
   ```this.pluginCommand({unit:'megad1', command:'/sec/?cmd=7:1;p10;7:0'});```

   Управление лентой WS2818
   ```this.pluginCommand({unit:'megad1', command:'/sec/?pt=35&ws=FF0000&chip=10');```

   
   Если переключается выход, можно в command отправить onResponse - что должно переключиться на интерфейсе:
  
   ```this.pluginCommand({unit:'megad1', command:{url:'/sec/?cmd=7:1;8:0', onResponse:[{id:"7",value:1},{id:"8",value:0}]});```
  

#### 2. Добавлена процедура восстановления выходов при перезагрузке контроллера
   - Добавлено свойство: "Восстанавливать выход при перезагрузке контроллера" 

   Для этих выходов при получении st=1 отправляется команда on, если выход был в on

#### 3. Добавлена процедура синхронизации времени
   - Добавлен параметр "Отправлять время на контроллер"

   Если галочка установлена, то при старте плагина и при получении с контроллера st=1 сервер отправляет время:
   ```/sec/?cf=7&stime=10:57:06:4```

#### 4. Изменен алгоритм отправки запросов 
   - Добавлен параметр "Интервал отправки запросов (мсек)"

#### 5. Добавлена возможность чтения датчиков I2C

  Запрос зависит от подключенного оборудования, подробнее см на сайте ab-log

  Отличие от существующего функционала: нет привязки к порту MegaD, которая нужна, если данные канала считываются по команде cmd=all. Подробнее см Общий принцип адресации каналов MegaD

  Например, есть запросы для I2C:

  ```/sec/?pt=31&scl=34&i2c_dev=htu21d&i2c_par=1```

  ```/sec/?pt=31&scl=34&i2c_dev=htu21d```
  
  Cоздаем два канала. ID каналов может быть любым, привязка к порту 31 не нужна!!!

  Например,  i2c_htu21d или htu21d_31 или mySensor 
   
#### 6. Добавлена возможность чтения и управления для DS2413
   
   - Запрос /sec/?pt=32&cmd=list
   - Ответ содержит как DS18B20, так и DS2413: 
   
   ```aad6a070000:25.43;85a56a070000:32.43;79c439000000:OFF/OFF;c6c439000000:ON/ON```

   Канал DS18B20 формируется как обычно: 32_aad6a070000

   Каналы DS2413: 32_79c439000000_A, 32_79c439000000_B
   
   Время для опроса нужно как обычно выставить только в одном из каналов!!
   
   Больше никакой настройки не требуется, команды управления будут сформированы автоматически: 

   ```/sec/?cmd=32A:1&addr=79c439000000```


#### 7. Добавлена функция обработки данных на плагине

  - Добавлены свойства
      - "Использовать функцию обработки при получении данных от контроллера" - checkbox
      - Функция обработки значения - многострочное поле для ввода функции

 Функция обработки аналогична Berry - за исключением возвращаемого значения.

 Вернуть нужно значение или undefined (return;)
 
  - Входные параметры: 
       - val - значение c контроллера
       - depo - объект, который хранит данные между вызовами функции
  
  Внутри объекта можно создавать любые структуры   
	      	
    function (val, depo) {
   	  if (!depo.res) depo.res = [];
   	  depo.res.push(val);

   	  if (depo.res.length < 5) return; //Нужны еще измерения, значение не возвращаем
 
      depo.res.sort();
      let result = ((depo.res[1] + depo.res[2] + depo.res[3]) / 3).toFixed(2);

   	  depo.res = []; //Перед следующими измерениями сбрасываем массив
  	  return result; // Возвращаем результат расчета
    } 


